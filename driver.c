#include "semanticAnalyzer.h"
#include "codegen.h"

ht* initialize () {
    readGrammarFile();
    computeFirstAndFollowSets();
    createParseTable();
    ht* lookup_table = init_ht();
    if(lookup_table == NULL) exit_nomem();
    fill_lookup_table(lookup_table);
    // print_lookup_table(lookup_table);
    return lookup_table;
}

void deallocateStructures (ht* lookup_table) {
    delete_ht(lookup_table);
    deallocateBuff();
    deallocateFromParser();
}

int main(int argc, char* argv[]) {

    int syntax_errors = -1;
    int semantic_errors = -1;

    clock_t start, end;

    ht* lookup_table = initialize();

    FILE* fp = fopen(argv[1], "r+");
    if(fp == NULL) {
        printf("Test file doesn't exist!\n");
        return 0;
    }
    fclose(fp);

    treeNode* parse_tree_root;
    Ast_Node* ast_root;
    STTreeNode* symbol_table_root;

    while(true) {
        printf("\nEnter a choice from 0 to 9:\n");
        printf("0. To exit from the loop.\n");
        printf("1. Lexer : For printing the token list generated by the lexer.\n");
        printf("2. Parser : For parsing to verify the syntactic correctness of the input source code and to produce parse tree.\n");
        printf("3. AST : For printing the Abstract Syntax Tree in appropriate format.\n");
        printf("4. Memory: For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used.\n");
        printf("5. Symbol Table : For printing the symbol table.\n");
        printf("6. Activation Record Size : For printing the total memory requirement for each function.\n");
        printf("7. Static and dynamic arrays : For printing the type expressions and width of array variables in a line.\n");
        printf("8. Errors reporting and total compiling time.\n");
        printf("9. Code generation : For producing assembly code.\n");

        int choice;
        scanf("%d", &choice);

        switch(choice)
        {
        case 0:
            return 0;
            break;
        case 1:
            fp = fopen(argv[1], "r+");
            printLexemes(fp, 30, lookup_table);
            fclose(fp);
            break;
        case 2:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, true);
            fclose(fp);
            printParseTree(parse_tree_root);
            break;
        case 3:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, true);
            fclose(fp);
            ast_root = wrapper_create_AST(parse_tree_root->firstchild);
            traverseAST(ast_root, NULL, stdout);
            break;
        case 4:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, false);
            int pn = get_total_tree_memory();
            int pm = pn * sizeof(treeNode);
            fclose(fp);
            ast_root = wrapper_create_AST(parse_tree_root->firstchild);
            int an = get_total_ast_memory();
            int am = an * sizeof(Ast_Node);
            printf("Parse Tree : Number of nodes = %d. Allocated Memory = %d bytes.\n", pn, pm);
            printf("AST : Number of nodes = %d. Allocated Memory = %d bytes.\n", an, am);
            double comp = (pm - am) * 100.0 / pm;
            printf("Compression Percentage = %2.6f percent.\n", comp);
            break;
        case 5:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, false);
            fclose(fp);
            ast_root = wrapper_create_AST(parse_tree_root->firstchild);
            symbol_table_root = generateSymbolTable(ast_root);
            print_symbol_table(symbol_table_root, stdout);
            break;
        case 6:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, false);
            fclose(fp);
            ast_root = wrapper_create_AST(parse_tree_root->firstchild);
            symbol_table_root = generateSymbolTable(ast_root);
            print_activation_record();
            break;
        case 7:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, false);
            fclose(fp);
            ast_root = wrapper_create_AST(parse_tree_root->firstchild);
            symbol_table_root = generateSymbolTable(ast_root);
            print_static_dynamic_arrays(symbol_table_root);
            break;
        case 8:
            start = clock();
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, false);
            fclose(fp);
            if(number_of_parsing_errors() > 0) {
                // Do nothing.
            } else {
                ast_root = wrapper_create_AST(parse_tree_root->firstchild);
                symbol_table_root = generateSymbolTable(ast_root);
                typecheckdfs(ast_root);
                semanticAnalyzer(ast_root);
                print_semantic_errors(stdout);
                if(number_of_semantic_errors() > 0) {
                    // Do nothing.
                }
            }
            end = clock();
            double total_time = (double) (end - start);
            double total_time_seconds = total_time / CLOCKS_PER_SEC;
            printf("Total time taken by the integrated compiler:\n");
            printf("Total CPU time : %2.6f ticks.\n", total_time);
            printf("Total CPU time in seconds : %2.6f.\n", total_time_seconds);
            break;
        case 9:
            fp = fopen(argv[1], "r+");
            start_lexer(fp, 30, true);
            parse_tree_root = parseInputSourceCode(lookup_table, fp, false);
            fclose(fp);
            if(number_of_parsing_errors() > 0) {
                printf("There are syntactical errors in the code. Please run option 2 or 7 to see the errors.\n");
            } else {
                ast_root = wrapper_create_AST(parse_tree_root->firstchild);
                symbol_table_root = generateSymbolTable(ast_root);
                typecheckdfs(ast_root);
                semanticAnalyzer(ast_root);
                if(number_of_semantic_errors() > 0) {
                    printf("There are semantic errors in the code. Please run option 8 to see the errors.\n");
                } else {
                    // Code Gen goes here!!!
                    FILE* cg = fopen(argv[2], "w+");
                    codegen(ast_root, cg);
                    fclose(cg);
                }
            }
            break;
        default:
            printf("Invalid input. Please specify a choice between 0 and 9 only.\n");
        }
    }
}
